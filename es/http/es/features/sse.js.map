{"version":3,"file":"sse.js","sources":["../../../../../http/es/features/sse.js"],"sourcesContent":["var t,e;(e=t||(t={})).CONNECTING=\"connecting\",e.CONNECTED=\"connected\",e.DISCONNECTING=\"disconnecting\",e.DISCONNECTED=\"disconnected\",e.ERROR=\"error\";class s{constructor(e){this.eventSource=null,this.status=t.DISCONNECTED,this.eventListeners=new Map,this.reconnectAttempts=0,this.reconnectTimer=null,this.heartbeatTimer=null,this.lastEventId=null,this.config={url:e.url,withCredentials:e.withCredentials??!1,headers:e.headers||{},autoReconnect:e.autoReconnect??!0,reconnectDelay:e.reconnectDelay??3e3,maxReconnectAttempts:e.maxReconnectAttempts??5,heartbeatTimeout:e.heartbeatTimeout??3e4,debug:e.debug??!1}}async connect(){if(this.status!==t.CONNECTED&&this.status!==t.CONNECTING)return new Promise((e,s)=>{this.status=t.CONNECTING,this.log(`Connecting to ${this.config?.url}`);try{let n=this.config?.url;if(this.lastEventId){const t=n.includes(\"?\")?\"&\":\"?\";n+=`${t}lastEventId=${encodeURIComponent(this.lastEventId)}`}this.eventSource=new EventSource(n,{withCredentials:this.config?.withCredentials}),this.eventSource.onopen=()=>{this.status=t.CONNECTED,this.reconnectAttempts=0,this.log(\"Connected\"),this.startHeartbeat(),this.emit(\"open\"),e()},this.eventSource.onmessage=t=>{this.handleMessage(t)},this.eventSource.onerror=e=>{this.log(\"Error:\",e),this.status===t.CONNECTING?(this.status=t.ERROR,this.emit(\"error\",e),s(e)):this.handleDisconnection()}}catch(e){this.status=t.ERROR,this.emit(\"error\",e),s(e)}});this.log(\"Already connected or connecting\")}disconnect(){this.log(\"Disconnecting\"),this.stopHeartbeat(),this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.eventSource&&(this.status=t.DISCONNECTING,this.eventSource.close(),this.eventSource=null),this.status=t.DISCONNECTED,this.emit(\"close\")}on(t,e){return this.addEventListener(t,e)}addEventListener(t,e){return this.eventListeners.has(t)||this.eventListeners.set(t,new Set),this.eventListeners.get(t).add(e),this.eventSource&&\"open\"!==t&&\"close\"!==t&&\"error\"!==t&&this.eventSource.addEventListener(t,e),()=>this.removeEventListener(t,e)}removeEventListener(t,e){const s=this.eventListeners.get(t);s&&s.delete(e),this.eventSource&&this.eventSource.removeEventListener(t,e)}once(t,e){const s=n=>{e(n),this.removeEventListener(t,s)};this.addEventListener(t,s)}getStatus(){return this.status}isConnected(){return this.status===t.CONNECTED}getReconnectAttempts(){return this.reconnectAttempts}getLastEventId(){return this.lastEventId}updateConfig(t){Object.assign(this.config,t),this.isConnected()&&t.heartbeatTimeout&&(this.stopHeartbeat(),this.startHeartbeat())}getEventSource(){return this.eventSource}getReadyState(){return this.eventSource?.readyState??EventSource.CLOSED}emit(t,e){const s=this.eventListeners.get(t);s&&s.forEach(t=>{try{t(e)}catch(t){this.log(\"Error in event listener:\",t)}})}handleMessage(t){this.resetHeartbeat(),t.lastEventId&&(this.lastEventId=t.lastEventId),this.log(\"Message received:\",t.data),this.emit(\"message\",{type:t.type,data:t.data,id:t.lastEventId})}handleDisconnection(){this.stopHeartbeat(),this.status=t.DISCONNECTED,this.emit(\"close\"),this.config?.autoReconnect&&this.reconnectAttempts<this.config?.maxReconnectAttempts?this.reconnect():this.reconnectAttempts>=this.config?.maxReconnectAttempts&&(this.log(\"Max reconnect attempts reached\"),this.emit(\"reconnect_failed\"))}reconnect(){this.reconnectAttempts++,this.log(`Reconnecting... (attempt ${this.reconnectAttempts}/${this.config?.maxReconnectAttempts})`),this.emit(\"reconnecting\",{attempts:this.reconnectAttempts}),this.eventSource&&(this.eventSource.close(),this.eventSource=null),this.reconnectTimer=setTimeout(async()=>{try{await this.connect(),this.log(\"Reconnected successfully\"),this.emit(\"reconnect\")}catch(t){this.log(\"Reconnect failed:\",t),this.handleDisconnection()}},this.config?.reconnectDelay*this.reconnectAttempts)}startHeartbeat(){this.config?.heartbeatTimeout<=0||(this.heartbeatTimer=setTimeout(()=>{this.log(\"Heartbeat timeout\"),this.handleDisconnection()},this.config?.heartbeatTimeout))}stopHeartbeat(){this.heartbeatTimer&&(clearTimeout(this.heartbeatTimer),this.heartbeatTimer=null)}resetHeartbeat(){this.stopHeartbeat(),this.startHeartbeat()}log(...t){this.config}}function n(t){return new s(t)}class i{constructor(t,e){this.handlers=new Map,this.client=new s({url:t,...e})}async subscribe(t,e){return this.handlers.has(t)||this.handlers.set(t,[]),this.handlers.get(t).push(e),this.client.isConnected()||await this.client.connect(),this.client.addEventListener(t,e)}unsubscribe(t){if(t){const e=this.handlers.get(t);e&&(e.forEach(e=>{this.client.removeEventListener(t,e)}),this.handlers.delete(t))}else this.handlers.forEach((t,e)=>{t.forEach(t=>{this.client.removeEventListener(e,t)})}),this.handlers.clear();0===this.handlers.size&&this.client.disconnect()}disconnect(){this.unsubscribe(),this.client.disconnect()}getClient(){return this.client}}function c(t,e){return new i(t,e)}export{i as BasicSSEClient,s as SSEClient,t as SSEStatus,c as createBasicSSEClient,n as createSSEClient};\n//# sourceMappingURL=sse.js.map\n"],"names":[],"mappings":";;;;;;;;;AAAA,IAAI,CAAA,CAAA,CAAE;AAAA,CAAG,IAAE,CAAA,KAAI,CAAA,GAAE,EAAC,CAAA,EAAI,aAAW,YAAA,EAAa,CAAA,CAAE,SAAA,GAAU,WAAA,EAAY,EAAE,aAAA,GAAc,eAAA,EAAgB,EAAE,YAAA,GAAa,cAAA,EAAe,EAAE,KAAA,GAAM,OAAA;;;;;;;"}